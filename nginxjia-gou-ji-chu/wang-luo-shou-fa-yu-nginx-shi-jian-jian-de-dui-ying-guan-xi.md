# 网络收发与Nginx事件间的对应关系

Nginx是一个事件驱动的框架 . 所谓事件 , 主要指的是网络事件 , Nginx每一个连接 , 会自然对应两个网络事件 , 一个读时间一个写事件 . 所以在深入理解Nginx的各种原理以及一些极端场景下的错误处理时 , 需要先理解什么是网络事件 .

#### 网络事件

![](/assets/wangluotuopu.png)

主机A\(例如:笔记本电脑\)发送一个HTTP的GET请求到主机B\(Nginx服务器\) , 过程中经历了哪些网络事件呢 ?

![](/assets/shujuliu.png)

在应用层里发送了GET请求 . 到了传输层主要在做一件事情 , 我的浏览器打开一个端口 , 例如从Windows的任务管理器中可以看到 , 传输层会把这个端口记下来 , 还会把Nginx打开的端口80,或443记录下来 . 接下来是网络层 , 会记录我们的主机所在的IP和目标主机 , 也就是Nginx所在的那台服务器的公网IP . 然后是链路层 , 再到以太网 . 再到路由器 , 记录一些运营商的下一段的IP , 经过广域网 , 最终跳转到主机B所在的机器中 , 最后 , 报文通过链路层-&gt;网络层-&gt;传输层 , 也就是那个打开了80/443端口的Nginx进程 . Nginx在它的HTTP状态处理机里 , 就会处理这个请求 .

这样一个流程里 , 网络报文扮演着一个怎样的角色呢 ?

#### TCP流与报文

![](/assets/tcpliuyubaowen.png)

上图即是一个报文 , 也就是说我们发送的HTTP协议会被切割成很多小的报文 , 在网络层会切割掉MTU , 以太网每个MTU是1500字节 . 在TCP层 , 会考虑最大的MTU值 , 这时每个报文只有几百字节 , 这个报文大小称为MSS , 所以每收到一个小于MSS大小的报文 , 其实就是一个网络事件 .

#### TCP协议与非阻塞接口

TCP协议中 , 网络事件是怎样和调用接口关联起来的 ?

![](/assets/wangluoshjian.png)

##### 读事件

* 请求建立TCP连接事件 , 实际上是发送了一个TCP报文 , 是一个读事件 , 对于Nginx来说 , 读取到了一个报文 . 所以就是Accept建立连接事件 . 
* TCP连接可读事件 , 发送一个消息 , 对Nginx也是一个读事件 , 就是Read读消息 . 
* TCP连接关闭事件 , 也就是浏览器关掉了 , 操作系统会发送一个要求关闭连接的事件 , 对于Nginx来说 , 还是一个读事件 . 因为它只是读取一个报文 . 

##### 写事件

当Nginx需要向浏览器发送响应的时候 , 需要把消息写到操作系统中 , 要求操作系统发送到网络中 , 这就是一个写事件 . 

像这样一些网络中的读写事件 , 通常在Nginx中 , 或者在任何一个异步事件的处理框架中 , 都会存在一个**事件收集 , 分发器** . 我们会定义每一类事件的消费者 , 也就是说事件是一个生产者 , 通过网络自动生产到Nginx中\(收集分发器\) , 对每一种事件都会建立一个消费者 , 例如上图中的 , 连接建立的事件消费者 , 就是对Accept的调用 , Nginx的HTTP模块就会去建立一个新的连接 , 还有很多读消息或者写消息事件 , 在HTTP状态机中 , 不同的时间段 , 就会调用不同的方法 , 也就是不同的消费者去处理 . 以上 , 就是一个**事件分发消费器** . 

包括AIO异步读写磁盘的事件 , 还有定时器事件 , 像是否超时 , 还有上面提到过的worker\_shutdown\_timeout , 也是一个定时器事件 , 也有相应的消费者 . 

